[{"title":"用pygame做一个调色板","date":"2017-03-06T05:03:50.650Z","path":"2017/03/06/用pygame做一个调色板/","text":"在网上看到一个调色板的源代码，但是没有任何注释,乍一看真是一脸懵逼…因为有很多方法都不知道，后面花了些时间去查了官方文档（英语不好很痛苦）然后自认为已经完全理解了这份代码，现在将这份代码逐行添加注释 先上效果图 上面三行分别表示三原色（R,G,B）,从左至右是对应的参数（0-255），数字越大颜色越浅（0,0,0）就是黑色，（255,255,255）是白色然后下面的区域就是颜色的展示了，标题可以得到当前的三个参数 先上源代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import pygamefrom pygame.locals import *from sys import exit pygame.init() screen = pygame.display.set_mode((640, 480), 0, 32) def create_scales(height): red_scale_surface = pygame.surface.Surface((640, height)) green_scale_surface = pygame.surface.Surface((640, height)) blue_scale_surface = pygame.surface.Surface((640, height)) for x in range(640): c = int((x/640.)*255.) #print x,c red = (c, 0, 0) green = (0, c, 0) blue = (0, 0, c) line_rect = Rect(x, 0, 1, height) pygame.draw.rect(red_scale_surface, red, line_rect) pygame.draw.rect(green_scale_surface, green, line_rect) pygame.draw.rect(blue_scale_surface, blue, line_rect) return red_scale_surface, green_scale_surface, blue_scale_surface red_scale, green_scale, blue_scale = create_scales(80) color = [127, 127, 127] while True: for event in pygame.event.get(): if event.type == QUIT: exit() screen.fill((0, 0, 0)) screen.blit(red_scale, (0, 00)) screen.blit(green_scale, (0, 80)) screen.blit(blue_scale, (0, 160)) x, y = pygame.mouse.get_pos() if pygame.mouse.get_pressed()[0]: for component in range(3): if y &gt; component*80 and y &lt; (component+1)*80: color[component] = int((x/639.)*255.) pygame.display.set_caption(&quot;PyGame Color Test - &quot;+str(tuple(color))) for component in range(3): pos = ( int((color[component]/255.)*639), component*80+40 ) pygame.draw.circle(screen, (255, 255, 255), pos, 20) pygame.draw.rect(screen, tuple(color), (0, 240, 640, 240)) pygame.display.update() 我加上注释的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import pygamefrom pygame.locals import *from sys import exit#导入库pygame.init()#在调用pygame的方法之前必须先初始化，让硬件做好准备screen = pygame.display.set_mode((640, 480), 0, 32)#这里是得到一个窗口，大小是640*480,0是窗口具有的特征，比如可以改变大小，全屏之类的，32代表了颜色，这个一般不改#额外说一句，以我自己的理解，其实这里的screen就是一块填充了整个窗口的大画布，我们后续可以通过设置很多小画布来覆盖这个大画布的某一个区域def create_scales(height):#创建三个小画布，也就是上图里的三个不同颜色的矩形，height为你需要的画布高度，宽度都是640 red_scale_surface = pygame.surface.Surface((640, height)) green_scale_surface = pygame.surface.Surface((640, height)) blue_scale_surface = pygame.surface.Surface((640, height))#创建三个小画布，此时画布只有大小，没有任何东西，默认是全黑~ for x in range(640):#按宽度为640像素一个一个去遍历，因为我们要做到在这640宽度里从左到右出现0~255种颜色 c = int((x/640.)*255.)#这里的点是取浮点数的意思，这句其实也很简单，就是把640分成255份，在0~255中有些数会出现2次，有些3次，无关紧要 red = (c, 0, 0) green = (0, c, 0) blue = (0, 0, c)#三种画布的颜色，因为我们的三个画布只需要自身的那一种颜色，所以其他两个为0即可 line_rect = Rect(x, 0, 1, height)#注意这里很关键，你需要理解下面的draw.rect函数，这里其实是一个比red_scale_surface更小的画布，我们每次覆盖red_scale_surface的一个1*height单位的矩形#四个参数分别为坐标的x和y，矩形的宽度以及高度 pygame.draw.rect(red_scale_surface, red, line_rect) pygame.draw.rect(green_scale_surface, green, line_rect) pygame.draw.rect(blue_scale_surface, blue, line_rect)#第一个参数为1号画布，第二个为颜色的元组，可以是(R,G,B)，也可以是(R,G,B,A),A是透明化的意思，一般不需要设置。#第三个参数为2号画布，表示将2号画布覆盖到1号画布的（x,y）位置 return red_scale_surface, green_scale_surface, blue_scale_surface red_scale, green_scale, blue_scale = create_scales(80) color = [127, 127, 127]#初始化颜色while True: for event in pygame.event.get(): if event.type == QUIT: exit()#接受到退出事件就退出 screen.fill((0, 0, 0))#把整块画布填满黑色，其实没有这条语句也无所谓，因为我们的小画布会填满这个大画布 screen.blit(red_scale, (0, 00)) screen.blit(green_scale, (0, 80)) screen.blit(blue_scale, (0, 160))#将R,G,B三块画布覆盖为大画布对应的位置，至此，上图中三条不同颜色的矩形就有了~并且颜色是从左到右变化的 x, y = pygame.mouse.get_pos()#获取鼠标的当前坐标 if pygame.mouse.get_pressed()[0]:#pygame.mouse.get_pressed()这个函数的结果是一个（0,0,0）三元组，分别表示鼠标左键，滚轮按下，右键，参数为1表示按下了#这里如果改成pygame.mouse.get_pressed()[2]就是判断鼠标是否按下右键啦 for component in range(3):#遍历三块画布，当我们按下一个位置时，我们需要找到是按下了那块画布 if y &gt; component*80 and y &lt; (component+1)*80:#这应该不用过多解释了，一个画布的高度是80嘛 color[component] = int((x/639.)*255.)#更新color列表~这里的公式跟上面是一样的，将x坐标转换成对应的（0~255）颜色数值了 pygame.display.set_caption(&quot;PyGame Color Test - &quot;+str(tuple(color)))#设置标题 for component in range(3): pos = ( int((color[component]/255.)*639), component*80+40 ) pygame.draw.circle(screen, (255, 255, 255), pos, 20)#画上画布中间的那个小圆，如果上面都能看懂，这里应该没啥问题了#circle的参数是（画布，颜色，坐标，圆半径，宽度），注意这个宽度不设置就为0，如果设置了一个数值，比如设置了10，那么就是在我当前圆中间挖掉一个半径为10的圆 pygame.draw.rect(screen, tuple(color), (0, 240, 640, 240))#画上下面用来展示颜色的区域，这里应该不用多说了，注意这个四元组就是上面的line_rect = Rect(x, y, width, height) pygame.display.update()#更新到屏幕 虽然是一个简单（起码不复杂）的小程序，但是感觉还是学到了不少东西主要是对游戏中各种区域的显示问题有了一点理解，其实就是各种大小不一的画布，画布有各自的颜色之类的属性，然后相互覆盖以上","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"},{"name":"pygame","slug":"pygame","permalink":"http://flandre.site/tags/pygame/"}]},{"title":"pygame中键盘事件的注意点","date":"2017-03-04T05:38:12.558Z","path":"2017/03/04/pygame中键盘事件的注意点/","text":"今天在做关于键盘事件的问题时，有一个百思不得其解的问题当我的代码为：123456789101112131415161718192021222324252627282930313233343536background_image_filename = &apos;sushiplate.jpg&apos;import pygamefrom pygame.locals import *from sys import exitpygame.init()screen = pygame.display.set_mode((640,480),0,32)background = pygame.image.load(background_image_filename).convert()x,y = 0,0move_x,move_y = 0,0while True: for event in pygame.event.get(): if event.type == QUIT: exit() if event.type == KEYDOWN: if event.key == K_LEFT: move_x = -1 if event.key == K_RIGHT: move_x = 1 if event.key == K_UP: move_y = -1 if event.key == K_DOWN: move_y = 1 elif event.type == KEYUP: move_x = 0 move_y = 0 x+= move_x y+= move_y screen.fill((0,0,0)) screen.blit(background,(x,y)) pygame.display.update() 会出现一个问题，我方向键按一下和长按，都只能移动一下。而当我把缩进改一下，变成如下代码：12345678910111213141516171819202122232425262728293031323334353637background_image_filename = &apos;sushiplate.jpg&apos;import pygamefrom pygame.locals import *from sys import exitpygame.init()screen = pygame.display.set_mode((640,480),0,32)background = pygame.image.load(background_image_filename).convert()x,y = 0,0move_x,move_y = 0,0while True: for event in pygame.event.get(): if event.type == QUIT: exit() if event.type == KEYDOWN: if event.key == K_LEFT: move_x = -1 if event.key == K_RIGHT: move_x = 1 if event.key == K_UP: move_y = -1 if event.key == K_DOWN: move_y = 1 elif event.type == KEYUP: move_x = 0 move_y = 0 #print event x+= move_x y+= move_y screen.fill((0,0,0)) screen.blit(background,(x,y)) pygame.display.update() 就可以实现长按移动多次 经过多次调试代码，终于发现了原因所在首先我们要对pygame.event.get()这个方法做一个比较充分的认识这个方法是在当发生任何事件的时候会进入循环但是当没有发生任何事件的时候，便不会进入for循环，会一直执行while循环! 基于此，我做了一下测试，关于长按方向键是一个事件还是多个事件，如上诉代码中的print event语句结果发现，长按方向键和按一下方向键都是一个事件，并且是完全相同的事件至此终于懂了这两份代码的区别 如果把更新坐标和画图放在循环外，没有事件发生时会一直更改坐标（因为move_x,move_y不为0），画图，直到我们放开方向键，就触发了KEYUP事件，把move_x和move_y的值改为0这样虽然还是一直在画图，但是坐标并没有发生改变 而当我们把这五条语句放在循环内部，只有第一次会更改下坐标并画图。然后就会跳出循环，一直在while循环里跑，而不作任何操作，因为此时没有任何新的事件发生了!","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"},{"name":"pygame","slug":"pygame","permalink":"http://flandre.site/tags/pygame/"}]},{"title":"pygame","date":"2017-03-03T04:57:57.694Z","path":"2017/03/03/pygame模块一览/","text":"忙于准备考研，每天中午学习一下pygame 各个模块 模块名 功能 pygame.cdrom 访问光驱 pygame.cursors 加载光标 pygame.display 访问显示设备 pygame.draw 绘制形状、线和点 pygame.event 管理事件 pygame.font 使用字体 pygame.image 加载和存储图片 pygame.joystick 使用游戏手柄或者 类似的东西 pygame.key 读取键盘按键 pygame.mixer 声音 pygame.mouse 鼠标 pygame.movie 播放视频 pygame.music 播放音频 pygame.overlay 访问高级视频叠加 pygame 就是我们在学的这个东西了…… pygame.rect 管理矩形区域 pygame.sndarray 操作声音数据 pygame.sprite 操作移动图像 pygame.surface 管理图像和屏幕 pygame.surfarray 管理点阵图像数据 pygame.time 管理时间和帧信息 pygame.transform 缩放和移动图像 创建窗口时的标志 标志位 功能 FULLSCREEN 创建一个全屏窗口 DOUBLEBUF 创建一个“双缓冲”窗口，建议在HWSURFACE或者OPENGL时使用 HWSURFACE 创建一个硬件加速的窗口，必须和FULLSCREEN同时使用 OPENGL 创建一个OPENGL渲染的窗口 RESIZABLE 创建一个可以改变大小的窗口 NOFRAME 创建一个没有边框的窗口 常用事件集 事件 产生途径 参数 QUIT 用户按下关闭按钮 none ATIVEEVENT Pygame被激活或者隐藏 gain, state KEYDOWN 键盘被按下 unicode, key, mod KEYUP 键盘被放开 key, mod MOUSEMOTION 鼠标移动 pos, rel, buttons MOUSEBUTTONDOWN 鼠标按下 pos, button MOUSEBUTTONUP 鼠标放开 pos, button JOYAXISMOTION 游戏手柄(Joystick or pad)移动 joy, axis, value JOYBALLMOTION 游戏球(Joy ball)?移动 joy, axis, value JOYHATMOTION 游戏手柄(Joystick)?移动 joy, axis, value JOYBUTTONDOWN 游戏手柄按下 joy, button JOYBUTTONUP 游戏手柄放开 joy, button VIDEORESIZE Pygame 窗口缩放 size, w, h VIDEOEXPOSE Pygame 窗口部分公开(expose)? none USEREVENT 触发了一个用户事件 code MOUSEMOTION事件会在鼠标动作的时候发生，它有三个参数： buttons – 一个含有三个数字的元组，三个值分别代表左键、中键和右键，1就是按下了。 pos – 就是位置了…… rel – 代表了现在距离上次产生鼠标事件时的距离 和MOUSEMOTION类似的，我们还有MOUSEBUTTONDOWN和MOUSEBUTTONUP,它们的参数为： button – 看清楚少了个s，这个值代表了哪个按键被操作 pos – 和上面一样 KEYDOWN和KEYUP的参数描述如下 key – 按下或者放开的键值，是一个数字，估计地球上很少有人可以记住，所以Pygame中你可以使用K_xxx来表示，比如字母a就是K_a，还有K_SPACE和K_RETURN等。 mod – 包含了组合键信息，如果mod &amp; KMOD_CTRL是真的话，表示用户同时按下了Ctrl键。类似的还有KMOD_SHIFT，KMOD_ALT。 unicode – 代表了按下键的Unicode值，这个有点不好理解，真正说清楚又太麻烦，游戏中也不太常用，说明暂时省略，什么时候需要再讲吧。 我们使用pygame.event.set_blocked(事件名)来完成过滤。如果有好多事件需要过滤，可以传递一个列表，比如pygame.event.set_blocked([KEYDOWN, KEYUP])，如果你设置参数None，那么所有的事件都被打开了。与之相对的，我们使用pygame.event.set_allowed()来设定允许的事件。 总结一下pygame.mouse pygame.mouse.get_pressed —— 返回按键按下情况，返回的是一元组，分别为(左键, 中键, 右键)，如按下则为Truepygame.mouse.get_rel —— 返回相对偏移量，(x方向, y方向)的一元组pygame.mouse.get_pos —— 返回当前鼠标位置(x, y)pygame.mouse.set_pos —— 显而易见，设置鼠标位置pygame.mouse.set_visible —— 设置鼠标光标是否可见pygame.mouse.get_focused —— 如果鼠标在pygame窗口内有效，返回Truepygame.mouse.set_cursor —— 设置鼠标的默认光标式样，是不是感觉我们以前做的事情白费了？哦不会，我们使用的方法有着更好的效果。pyGame.mouse.get_cursor —— 不再解释。","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"},{"name":"pygame","slug":"pygame","permalink":"http://flandre.site/tags/pygame/"}]},{"title":"网易云音乐常用API浅析","date":"2017-02-22T05:40:18.681Z","path":"2017/02/22/网易云音乐常用API浅析/","text":"此文转自 http://moonlib.com/606.html由于本人不会抓客户端的包，多亏了这位dalao的这篇博客才让我成功完成下载网易云歌曲的爬虫 话不多说PC客户端抓包而来 0.说明关于头部信息12Cookie: os=pc; deviceId=B55AC773505E5606F9D355A1A15553CE78B89FC7D8CB8A157B84; osver=Microsoft-Windows-8-Professional-build-9200-64bit; appver=1.5.0.75771; usertrack=ezq0alR0yqJMJC0dr9tEAg==; MUSIC_A=088a57b553bd8cef58487f9d01aeUser-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.138 Safari/537.36\\r\\n 上面是抓到的信息，其中必要的只有cookie中的appver。而且如果要调用api，必须加上Referer，只要是music.163.com的就可以 12Cookie: appver=1.5.0.75771;Referer: http://music.163.com/ 以上两条即可返回的格式均为json 1.搜索抓取到的信息如下123456789101112131415Full request URI：http://music.163.com/api/search/pcKey: hlpretagValue: &lt;span class=&quot;s-fc2&quot;&gt;Key: hlposttagValue: &lt;/span&gt;Key: sValue: \\345\\226\\234\\346\\254\\242\\344\\275\\240Key: offsetValue: 0Key: totalValue: trueKey: limitValue: 100Key: typeValue: 1 URL： POST http://music.163.com/api/search/pc必要参数： s：搜索的内容 offset：偏移量（分页用） limit：获取的数量 type：搜索的类型 歌曲 1 专辑 10 歌手 100 歌单 1000 用户 1002 mv 1004 歌词 1006 主播电台 10092.歌曲信息1Full request URI: http://music.163.com/api/song/detail/?id=28377211&amp;ids=%5B28377211%5D URL： GET http://music.163.com/api/song/detail/必要参数： id：歌曲ID ids：不知道干什么用的，用[]括起来的歌曲ID 3.歌手专辑1Full request URI: http://music.163.com/api/artist/albums/166009?id=166009&amp;offset=0&amp;total=true&amp;limit=5 URL： GET http://music.163.com/api/artist/albums/歌手ID必要参数： limit：获取的数量(不知道为什么这个必须加上） 4.专辑信息1Full request URI: http://music.163.com/api/album/2457012?ext=true&amp;id=2457012&amp;offset=0&amp;total=true&amp;limit=10 URL： GET http://music.163.com/api/album/专辑ID 5.歌单1Full request URI: http://music.163.com/api/playlist/detail?id=37880978&amp;updateTime=-1 URL： GET http://music.163.com/api/playlist/detail必要参数： id：歌单ID 6.歌词URL： GET http://music.163.com/api/song/lyric必要参数： id：歌曲ID lv：值为-1，我猜测应该是判断是否搜索lyric格式 kv：值为-1，这个值貌似并不影响结果，意义不明 tv：值为-1，是否搜索tlyric格式 7.MV1Full request URI: http://music.163.com/api/mv/detail?id=319104&amp;type=mp4 URL： GET http://music.163.com/api/mv/detail必要参数： id：mvid type：值为mp4，视频格式，不清楚还有没有别的格式 PHP版使用示例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?php/** * Created by PhpStorm. * User: Moon * Date: 2014/11/26 0026 * Time: 2:06 */function curl_get($url)&#123; $refer = &quot;http://music.163.com/&quot;; $header[] = &quot;Cookie: &quot; . &quot;appver=1.5.0.75771;&quot;; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HTTPHEADER, $header); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_BINARYTRANSFER, true); curl_setopt($ch, CURLOPT_REFERER, $refer); $output = curl_exec($ch); curl_close($ch); return $output;&#125; function music_search($word, $type)&#123; $url = &quot;http://music.163.com/api/search/pc&quot;; $post_data = array( &apos;s&apos; =&gt; $word, &apos;offset&apos; =&gt; &apos;0&apos;, &apos;limit&apos; =&gt; &apos;20&apos;, &apos;type&apos; =&gt; $type, ); $referrer = &quot;http://music.163.com/&quot;; $URL_Info = parse_url($url); $values = []; $result = &apos;&apos;; $request = &apos;&apos;; foreach ($post_data as $key =&gt; $value) &#123; $values[] = &quot;$key=&quot; . urlencode($value); &#125; $data_string = implode(&quot;&amp;&quot;, $values); if (!isset($URL_Info[&quot;port&quot;])) &#123; $URL_Info[&quot;port&quot;] = 80; &#125; $request .= &quot;POST &quot; . $URL_Info[&quot;path&quot;] . &quot; HTTP/1.1\\n&quot;; $request .= &quot;Host: &quot; . $URL_Info[&quot;host&quot;] . &quot;\\n&quot;; $request .= &quot;Referer: $referrer\\n&quot;; $request .= &quot;Content-type: application/x-www-form-urlencoded\\n&quot;; $request .= &quot;Content-length: &quot; . strlen($data_string) . &quot;\\n&quot;; $request .= &quot;Connection: close\\n&quot;; $request .= &quot;Cookie: &quot; . &quot;appver=1.5.0.75771;\\n&quot;; $request .= &quot;\\n&quot;; $request .= $data_string . &quot;\\n&quot;; $fp = fsockopen($URL_Info[&quot;host&quot;], $URL_Info[&quot;port&quot;]); fputs($fp, $request); $i = 1; while (!feof($fp)) &#123; if ($i &gt;= 15) &#123; $result .= fgets($fp); &#125; else &#123; fgets($fp); $i++; &#125; &#125; fclose($fp); return $result;&#125; function get_music_info($music_id)&#123; $url = &quot;http://music.163.com/api/song/detail/?id=&quot; . $music_id . &quot;&amp;ids=%5B&quot; . $music_id . &quot;%5D&quot;; return curl_get($url);&#125; function get_artist_album($artist_id, $limit)&#123; $url = &quot;http://music.163.com/api/artist/albums/&quot; . $artist_id . &quot;?limit=&quot; . $limit; return curl_get($url);&#125; function get_album_info($album_id)&#123; $url = &quot;http://music.163.com/api/album/&quot; . $album_id; return curl_get($url);&#125; function get_playlist_info($playlist_id)&#123; $url = &quot;http://music.163.com/api/playlist/detail?id=&quot; . $playlist_id; return curl_get($url);&#125; function get_music_lyric($music_id)&#123; $url = &quot;http://music.163.com/api/song/lyric?os=pc&amp;id=&quot; . $music_id . &quot;&amp;lv=-1&amp;kv=-1&amp;tv=-1&quot;; return curl_get($url);&#125; function get_mv_info()&#123; $url = &quot;http://music.163.com/api/mv/detail?id=319104&amp;type=mp4&quot;; return curl_get($url);&#125; #echo music_search(&quot;Moon Without The Stars&quot;, &quot;1&quot;);#get_music_info(&quot;28949444&quot;);#echo get_artist_album(&quot;166009&quot;, &quot;5&quot;);#echo get_album_info(&quot;3021064&quot;);#echo get_playlist_info(&quot;22320356&quot;);#echo get_music_lyric(&quot;29567020&quot;);#echo get_mv_info(); 此文先到这，等到本人学会了如何抓取api再来更新python版的代码。","tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://flandre.site/tags/爬虫/"}]},{"title":"网易云音乐歌曲爬虫","date":"2017-02-22T05:31:03.762Z","path":"2017/02/22/网易云音乐歌曲爬虫/","text":"关于网易云音乐的爬虫（如果以后还有会继续更新此博客） 爬网易云音乐某个歌单的全部歌曲的全部热门评论，内容保存在D:\\comment 爬网易云音乐某个歌单的全部歌曲，内容保存在D:\\music（极少部分歌曲可能无法下载成功，本人试验了几个歌单，基本超过90%的歌曲能下下来） 下载网易云音乐的某一首歌，付费的也可以。内容保存在D:\\music（同上，小几率会出现无法下载成功的情况） 代码：点我","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://flandre.site/tags/爬虫/"}]},{"title":"网易云音乐免费下载付费歌曲的办法","date":"2017-02-21T09:37:31.270Z","path":"2017/02/21/网易云音乐免费下载付费歌曲的办法/","text":"1.你需要一个谷歌浏览器 2.用谷歌浏览器进网易云音乐网页版，搜索你想要下载的歌曲3.按下F12，选Network，在下面再选XHR 4.找一下有没有url开头的文件，如果没有就按一下播放按钮，就会出来一个url开头的文件，点一下，再点Preview，复制url的内容 5.进入这个url的网址，再点击下载就可以直接下了","tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://flandre.site/tags/小技巧/"}]},{"title":"【福利】atlas爬虫","date":"2017-02-20T14:46:21.649Z","path":"2017/02/20/【福利】atlas爬虫/","text":"http://girl-atlas.net/↑这个网站的爬虫会把200多页的图片全部分类好爬下来存在D盘的atlas文件夹里造福室友系列代码:https://github.com/cxq80803716/atlas","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://flandre.site/tags/爬虫/"}]},{"title":"豆瓣读书爬虫","date":"2017-02-17T08:45:13.007Z","path":"2017/02/17/豆瓣读书爬虫/","text":"此爬虫实现的功能是把xx标签的书全部下载下来，放入一个excel文件中，并且按照评分从高到低排列参考的来源是豆瓣读书 代码：https://github.com/cxq80803716/douban_spider","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://flandre.site/tags/爬虫/"}]},{"title":"用google浏览器爬取JS生成的网页时network的使用","date":"2017-02-15T06:50:14.696Z","path":"2017/02/15/用google浏览器爬取JS生成的网页时network的使用/","text":"本文转自这位dalao的博客https://yoghurt-lee.github.io/2017/02/14/google-network/ 如何使用network 在某网站,比如我自己的页面,按F12,出现如下界面,找到其中的network,然后按F5刷新.然后会获得传输的所有数据包. network下面有一个Preserve log,之前默认是没有点击的.如果打上勾,当你从上一个网页跳转到下一个网站时,本来上一个网页的数据会被清空,如果打上勾,那么前面的过程也会被记录,这个很重要,比如当你登录到某网站时打上勾就可以看到登录页面传送的信息. 下图所显示的也就是我们所抓到的包了,一般在ALL里面找数据,但是如果想看其余的信息,比如js,则可以看点击相应的元素. 以上是network的基本应用,下面说如何查看包中数据. network中数据包怎么看 静态网页中的数据一般很容易找到,但是如果是js生成的数据,那么在网页的源代码中是无法看到的,比如说这个网站,我们需要这个表格的信息(图一).但是我们在源代码中只能看到如下信息(图二).(图一)(图二) 解决方法只有两种,模拟这个网页的js代码生成数据,这不太现实;另一种就是分析包数据包,找到需要的信息.方法如下,在下面的数据包的信息里面点击Preview,就可以看到该数据包所携带的信息,一般都是以json数据(类似于python的dict)的形式储存在里面. OK,找到了数据,接下来就是怎么获得这些数据了.接下来点击该数据包的Headers,看如下信息:我们发现了该数据源的url,发现了该网页是以post方法进行访问的.既然是post,那么下面应该会有数据,我们接着往下看. 翻到了下面,果然访问该数据源是要携带数据的,我们只要利用这些数据,就可以顺利获得该数据源的信息了. 以下是python实现爬取这些数据的一般模板代码1234567891011121314151617181920import cookielibimport jsonimport urllib2import urllib#获得一个cookieJar实例cj = cookielib.CookieJar()#cookieJar作为参数，获得一个opener的实例opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))#伪装成一个正常的浏览器，避免有些web服务器拒绝访问。opener.addheaders = [(&apos;User-agent&apos;,&apos;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&apos;)]#需要访问数据源Headers中的的urlurl = &quot;XXXXXXXXX&quot;#最下面需要提交的数据,以键值对进行储存submit_data = urllib.urlencode(&#123;&quot;xxx&quot;:&quot;XXX&quot;,&quot;yyy&quot;:&quot;YYY&quot;&#125;)#以post的方法访问登陆页面，访问之后cookieJar会自定保存cookieop = opener.open(url,submit_data)#读取获得的数据源data = op.read()#解析成json数据,接下来就可以直接以键值对的方式访问数据源了data = json.loads(data)","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://flandre.site/tags/爬虫/"},{"name":"抓包","slug":"抓包","permalink":"http://flandre.site/tags/抓包/"}]},{"title":"本人写的杭电oj爬虫","date":"2017-02-13T18:48:18.690Z","path":"2017/02/14/本人写的杭电爬虫/","text":"项目已经更新，现在是2.0版本经过本人尝试，exe文件会有无法正确爬取代码的问题所以这里只提供源代码了，欢迎有python环境的朋友下载试用 最近在学爬虫，今天1.0版终于出来了欢迎下载试用网址：https://github.com/cxq80803716/hdu","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://flandre.site/tags/爬虫/"}]},{"title":"如何在github上传项目","date":"2017-02-13T18:32:08.651Z","path":"2017/02/14/如何在github上传项目/","text":"【第一步】 创建仓库这一步我想不用多说，直接在github里创建一个代码仓库用来存放项目就可以【第二步】 克隆仓库关于这一步，可以选择用github的客户端来clone项目到本地也可以用我们熟悉的Git Bash客户端的做法我就不多说了，下一个就一目了然了来说一说git的操作流程，首先，如果是一个新账号。要将公钥与私钥匹配，这点如果用过github的话都知道，也不多说了输入1ssh -T git@github.com 如果返回successfully就是成功了由于一个账号可以创建多个仓库，因此用来存放开源项目是相当方便的（所以github才是个IT宝地）在我们想要clone的文件夹下进入Git Bash，然后输入1git clone https://github.com/xxxxxx.git 上面的网址也就是你的仓库地址了，记得加git哦 【第三步】 上传README.md文件如果文件夹下右README.md文件了跳过这一步创建的流程如下：123456git inittouch README.mdgit add README.mdgit commit -m &apos;first_commit&apos;git remote add origin https://github.com/xxxx.gitgit push origin master 这里其实是创建完后顺便发布到github上去了，创建只到add语句 【第四步】 push文件到github上去代码是：1234git add .（这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。注意add后面有个点，表示全部）git commit -m &apos;first_commit&apos;git remote add origin https://github.com/xxxx.gitgit push origin master 如果执行git remote add origin https://github.com/xxxx.git，出现错误：1fatal: remote origin already exists 则执行以下语句：1git remote rm origin 再往后执行git remote add origin https://github.com/xxxx.git 即可。 在执行git push origin master时，报错：1error:failed to push som refs to....... 则执行以下语句：1git pull origin master","tags":[{"name":"github","slug":"github","permalink":"http://flandre.site/tags/github/"}]},{"title":"使用py2exe将python项目变成可执行exe文件","date":"2017-02-13T17:30:27.265Z","path":"2017/02/14/使用py2exe将python项目变成可执行exe文件/","text":"写完python程序后,我们想要进行分享，但是,许多人的电脑并没有安装python,那么我们可以用py2exe让python项目生成exe文件. 安装py2exe1.去官网下载对应的py2exe版本2.下载完后进行安装3.也可以用pip install py2exe进行安装 在项目文件下建立setup.py在你的项目下新建一个setup.py文件，内容是1234#coding:utf-8from distutils.core import setupimport py2exesetup(console=[&quot;main.py&quot;]) #console=&quot;主项目名.py&quot; 生成exe文件 cmd控制台先进入你的项目文件夹下(D:可以进入D盘,cd xxx可以进入xxx文件夹,cd ..可以退出当前文件夹),然后运行 1python setup.py py2exe 如果你的项目中有第三方库,那么生成的exe文件可能会出现闪退现象,我们需要运行如下命令将第三方库和exe文件链接起来: 1python setup.py py2exe -p 第三方库的名字 3.比如我写的一个项目，需要1python setup.py py2exe -p lxml,gzip 注意不能生成完exe文件再导入库直接导入库就可以了，这里的导入包含了生成exe文件 你可能会遇到一些编码问题我就是main.py在控制台运行没问题，但是生成exe文件后运行就报某条语句编码错误。比如我有一条代码是：1postdata = urllib.urlencode(postdata) 就会报超过了ascll表，可能是因为程序默认是ascll。所以出现中文啥的就要报错,改为1postdata = urllib.urlencode(postdata,&apos;utf-8&apos;) 后问题解决","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"}]},{"title":"python安装lxml模块失败的解决方法","date":"2017-02-12T11:13:06.527Z","path":"2017/02/12/python安装lxml模块失败的解决方法/","text":"以前这个问题就困扰了我很长时间，后面算是半解决了我的开发环境是ecplise+pydev，虽然import lxml程序不会报错但是ecplise总是提醒我这句代码是错的，我也就当做没看到了能用就好今天突然想彻底解决这个问题，于是就动手百度了最后在知乎找到解决办法 作者：深海鱼链接：https://www.zhihu.com/question/30047496/answer/69754268来源：知乎 安装wheel，命令行运行：pip install wheel 在这里下载对应的.whl文件，注意别改文件名！(这里本人做一点补充，这里这么多个.whl要选哪个呢？可以参考这个，里面给出了看版本的方法) 进入.whl所在的文件夹，执行命令即可完成安装pip install 带后缀的完整文件名","tags":[{"name":"python","slug":"python","permalink":"http://flandre.site/tags/python/"}]},{"title":"各种html状态返回代码","date":"2017-02-12T08:46:20.845Z","path":"2017/02/12/各种html状态返回代码/","text":"作者：La Sha链接：https://www.zhihu.com/question/20908415/answer/24823723来源：知乎 http状态返回代码 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 http状态返回代码 2xx （成功）表示成功处理了请求的状态代码。 http状态返回代码 代码 说明200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。http状态返回代码 3xx （重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 http状态返回代码 代码 说明300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 http状态返回代码 4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 http状态返回代码 代码 说明400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 http状态返回代码 5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 http状态返回代码 代码 说明500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 一些常见的http状态返回代码为：200 - 服务器成功返回网页404 - 请求的网页不存在503 - 服务不可用","tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://flandre.site/tags/爬虫/"},{"name":"html","slug":"html","permalink":"http://flandre.site/tags/html/"}]},{"title":"error deployer not found:github的解决方法","date":"2017-02-05T08:12:19.950Z","path":"2017/02/05/error_deployer_not _oundgithub的解决方法/","text":"在部署hexo的时候遇到过几次这个问题，每次都是用这个方法解决的。先注意type冒号之后是不是有记得加了空格如果是，就运行一下 $npm install hexo-deployer-Git –save然后再 hexo deploy","tags":[{"name":"github","slug":"github","permalink":"http://flandre.site/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://flandre.site/tags/hexo/"}]},{"title":"hexo部署后不能正常显示","date":"2017-02-04T15:57:18.623Z","path":"2017/02/04/hexo部署后不能正常显示/","text":"我们可能会遇到这么一种情况，本地hexo s是正常的，但是hexo g -d部署到服务器后显示出错了解决方法：hexo的_config.yml中有这么两个参数改为:url: http://www.yuming.com/blog/root: /blog","tags":[{"name":"github","slug":"github","permalink":"http://flandre.site/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://flandre.site/tags/hexo/"}]},{"title":"给hexo添加评论功能","date":"2017-02-04T15:39:46.620Z","path":"2017/02/04/给hexo添加duoshuo功能/","text":"申请一个多说账号，然后创建一个新站点箭头所指的域名尤为重要我用的主题是yilia，然后只要在themes\\yilia_config.yml里写上duoshuo: …（刚刚的域名）即可hexo s一下就有评论功能了~ 没事看一下多说的站点信息可以看到有没有新评论","tags":[{"name":"github","slug":"github","permalink":"http://flandre.site/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://flandre.site/tags/hexo/"}]},{"title":"github+hexo首页及博客怎么播放背景音乐","date":"2017-02-04T14:06:05.026Z","path":"2017/02/04/github+hexo首页及博客怎么播放音乐/","text":"现在已经有的背景音乐是主页的Rain，我再在这里放一首音乐作为例子，因为主页和博客内部的音乐设置方法不一样。 一.博客内如何插入背景音乐首先我们进入网易云音乐网页版，就是这个http://music.163.com/#搜索你想设置的背景音乐，这里我们以前前前世为例。然后我们可以自由选择这个音乐框的宽度及高度，是否自动播放。参数里的auto为0就是不自动播放，1就是自动播放。比如我的主页背景音乐Rain就是自动播放，这条博客的前前前世就不是自动播放。然后我们就获得了一段该音乐的html代码在我们用hexo写博客的时候会用到markdown，我们只要把这段代码直接贴在你想要放的位置就可以了。比如我这篇博客是直接把音乐放在开头，那么 二.主页如何插入背景音乐关于这个问题，不同的主题可能不太一样，但是本质是一样的。首先还是跟前面一样在网易云音乐中获得外链然后我们应该贴在哪里呢？答案是主题的layout布局文件里。比如我的是yilia，那么就是D:\\hexo\\themes\\yilia\\layout然后我们只要在这里的文件里找到我们要放播放器的位置代码就可以了。比如我的博客，我把它放在了左边。 那么就是D:\\hexo\\themes\\yilia\\layout_partial\\left-col.ejs不同的主题不一样，仔细找应该可以找到的。打开后我们可以看到这样的内容然后我们在对应的地方插入播放器代码就可以了看不懂也没关系，在一个一个标签下试一试就行。 仍未解决的地方主页设置背景音乐后在进入某一篇博客后还是会自动播放，还未找到解决方法。","tags":[{"name":"github","slug":"github","permalink":"http://flandre.site/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://flandre.site/tags/hexo/"}]},{"title":"博客搬家","date":"2017-02-04T13:44:21.320Z","path":"2017/02/04/博客搬家/","text":"自从暑假acm退役之后，就没怎么写过博客了这几天一时兴起学了github+hexo搭建博客嗯，原博客地址：http://blog.csdn.net/acm_cxq","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://flandre.site/tags/杂谈/"}]}]